{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Burrito Documentation","text":"<p>This is the home of the Burrito documentation. Here you will find all the information you need to get started with Burrito.</p> <ul> <li>Overview helps you understand what Burrito is all about.</li> <li>Getting Started is a step-by-step guide to help you get started with Burrito.</li> <li>Guides provides detailed tutorials to help you understand how to use Burrito.</li> <li>Operator Manual is a detailed guide to help you understand how to install and configure Burrito.</li> <li>User Guide is a detailed guide to help you understand how to setup and use Burrito resources.</li> <li>Contributing provides information on how to contribute to the Burrito project.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>First off, thank you for considering contributing to Burrito! Your support helps make this project better for everyone.</p> <p>The following is a set of tutorials and guidelines for contributing to Burrito. These are mostly guidelines, not rules. Use your best judgment, and feel free to propose changes to this document.</p>"},{"location":"contributing/#how-can-i-contribute","title":"How Can I Contribute?","text":""},{"location":"contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>If you find a bug, please report it by opening an issue on the issue tracker. Before reporting, please check whether the issue has already been reported.</p> <ul> <li>Ensure the bug hasn't been reported yet.</li> <li>Use a clear and descriptive title.</li> <li>Provide detailed steps to reproduce the issue.</li> <li>Include any relevant logs or screenshots.</li> </ul>"},{"location":"contributing/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>We welcome suggestions for improvements. Please use the issue tracker to submit enhancement requests.</p> <ul> <li>Use a clear and descriptive title.</li> <li>Explain why this enhancement would be useful.</li> <li>Provide examples or mockups if possible.</li> </ul>"},{"location":"contributing/#contributing-code","title":"Contributing Code","text":"<ul> <li>Set up a development environment following the steps below.</li> <li>Read the Development Guidelines.</li> <li>Submit contributions!</li> </ul>"},{"location":"contributing/#getting-started-set-up-a-local-development-environment-kind","title":"Getting Started: Set Up a Local Development Environment (kind)","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>A container runtime (docker, podman, etc.)</li> <li>Git</li> <li>Kind</li> <li>Helm</li> <li><code>kubectl</code></li> <li><code>yq</code></li> <li><code>make</code></li> </ul> <p>To run an instance of Burrito, you will need a Kubernetes cluster. This tutorial uses Kind as a local development Kubernetes cluster.</p> <p>Follow Kind's quick start tutorial to set up a local cluster.</p> <p>Once your cluster is up and running, follow the next steps to compile and deploy Burrito.</p>"},{"location":"contributing/#basic-install","title":"Basic Install","text":"<p>Follow these steps to install a minimal working configuration of Burrito on a Kind cluster:</p> <ul> <li>Cert-manager</li> <li>Burrito controllers in the <code>burrito-system</code> namespace</li> <li>A datastore running with mock storage (in-memory)</li> <li>A <code>TerraformRepository</code> and an associated <code>TerraformLayer</code> resource in the <code>burrito-project</code> namespace, pointing to the padok-team/burrito-examples repository</li> </ul> <p>Before starting, check that your local Kind cluster is running and that your context is set to target this cluster</p> <ol> <li>Install cert-manager on your cluster: <pre><code>helm repo add bitnami https://charts.bitnami.com/bitnami\nhelm upgrade --install -n cert-manager --create-namespace cert-manager bitnami/cert-manager --set installCRDs=true\n</code></pre></li> <li> <p>Fork and clone this repository.</p> </li> <li> <p>Run the following command to build a local image of Burrito, load it into your Kind cluster, and install Burrito with development Helm values:</p> <pre><code>make upgrade-dev-kind\n</code></pre> </li> <li> <p>Check that Burrito is running in the <code>burrito-system</code> namespace: <pre><code>kubectl get pods -n burrito-system\n</code></pre></p> <p>The output should be similar to:</p> <pre><code>NAME                                  READY   STATUS    RESTARTS   AGE\nburrito-controllers-7657b7455-2ldtd   1/1     Running   0          5m32s\nburrito-datastore-5967f46497-tfzgg    1/1     Running   0          5m32s\nburrito-server-5b6fb78949-ngcnt       1/1     Running   0          5m32s\n</code></pre> </li> <li> <p>Create layers and repository resources:</p> <p>Create a <code>dev</code> directory in <code>deploy/charts/burrito/templates/</code> and add a <code>dev.yaml</code> manifest with development resources:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n    name: my-layer\n    namespace: burrito-project\nspec:\n    branch: main\n    path: terraform/\n    repository:\n    name: my-repository\n    namespace: burrito-project\n---\napiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n    name: my-repository\n    namespace: burrito-project\nspec:\n    repository:\n    url: https://github.com/padok-team/burrito-examples\n    remediationStrategy:\n    autoApply: true\n    terraform:\n    enabled: true\n    opentofu:\n    enabled: false\n    terragrunt:\n    enabled: false\n</code></pre> </li> <li> <p>Refresh your Helm configuration:</p> <pre><code>make upgrade-dev-helm\n</code></pre> </li> <li> <p>Check that a runner pod is created for the newly created layer:</p> <pre><code>kubectl get pods -n burrito-project\n</code></pre> <p>The output should be similar to:</p> <pre><code>NAME                   READY   STATUS      RESTARTS   AGE\nmy-layer-apply-gxjhd   0/1     Completed   0          2m36s\n</code></pre> </li> </ol>"},{"location":"contributing/#refresh-commands","title":"Refresh Commands","text":"<p>To build a new local image of Burrito, push it into your local Kind cluster, and update the Helm release with the new image tag, run the following:</p> <pre><code>make upgrade-dev-kind\n</code></pre> <p>To refresh the Helm chart with development values, run:</p> <pre><code>make upgrade-dev-helm\n</code></pre> <p>Check the Makefile for more details about these commands.</p>"},{"location":"contributing/#advanced-settings","title":"Advanced Settings","text":"<p>Configure a GitHub Token for TENV</p> <p>It is strongly recommended to create a GitHub token with no specific rights to bypass the GitHub API rate limiting. Append the following configuration to your development <code>TerraformRepository</code> resources:</p> <pre><code>  overrideRunnerSpec:\n    env:\n      - name: TENV_GITHUB_TOKEN\n        value: ghp_xxxxx\n</code></pre>"},{"location":"contributing/#development-guidelines","title":"Development Guidelines","text":""},{"location":"contributing/#testing","title":"Testing","text":"<ul> <li>Write tests for new features or bug fixes.</li> <li>Run all tests to ensure existing functionality isn't broken (<code>make test</code>).</li> <li>Ensure code coverage remains at the same level or higher.</li> </ul>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<ul> <li>Please follow the convention described by Conventional Commits.</li> <li>If you don't, the CI pipeline will fail.</li> </ul>"},{"location":"contributing/#additional-resources","title":"Additional Resources","text":"<ul> <li>Controller-runtime documentation (Burrito heavily relies on this package)</li> <li>Burrito documentation</li> </ul>"},{"location":"faq/","title":"TODO - FAQ","text":""},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>A kubernetes cluster</li> <li>[Optional for testing, necessary for production use] A storage bucket in a cloud provider (AWS, GCP, Azure)</li> <li>[Optional, recommended for production use] cert-manager installed in your cluster (for internal encryption of plans and logs &amp; provider cache)</li> </ul>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>helm CLI</li> <li>Have a kubeconfig file (default location is <code>~/.kube/config</code>) to access your Kubernetes cluster</li> </ul>"},{"location":"getting-started/#1-install-burrito","title":"1. Install burrito","text":"<p>Copy and modify the default values to match your requirements.</p> <p>Make sure to configure a tenant by updating the <code>tenant</code> field in the <code>values.yaml</code> file. The associated namespace will be created automatically and used to deploy Burrito resources on step 3.</p> <p>For example, here is a default <code>values.yaml</code> file: <pre><code>config:\n  datastore:\n    storage:\n      mock: true\n\ntenants:\n  - namespace:\n      create: true\n      name: \"burrito-project-1\"\n    serviceAccounts:\n      - name: \"runner-project-1\"\n</code></pre></p> <p>Info</p> <p>To try Burrito without setting up a remote storage, set the <code>config.burrito.datastore.storage.mock</code> field to <code>true</code> in the <code>values.yaml</code> file. To persist data such as terraform logs, you must configure a storage bucket field. Make sure to specify a service account that has the necessary permissions to read/write to your remote bucket.</p> <p>Then, install Burrito using the following command:</p> <pre><code>helm install burrito oci://ghcr.io/padok-team/charts/burrito --create-namespace -n burrito-system -f ./values.yaml\n</code></pre> <p>This will create a new namespace, <code>burrito-system</code>, where burrito services will be deployed.</p>"},{"location":"getting-started/#2-create-a-connection-to-a-private-repository","title":"2. Create a connection to a private repository","text":"<p>Create a Kubernetes <code>Secret</code> to reference the necessary credentials to clone your IaC repository (github or gitlab)</p> <pre><code>kind: Secret\nmetadata:\n  name: burrito-repo\n  namespace: &lt;tenant-namespace&gt;\ntype: Opaque\nstringData:\n  username: &lt;my-username&gt;\n  password: &lt;my-password | my-access-token&gt;\n  sshPrivateKey: |\n    -----BEGIN OPENSSH PRIVATE KEY-----\n    ...\n    -----END OPENSSH PRIVATE KEY-----\n</code></pre> <p>Then, create a <code>TerraformRepository</code> Kubernetes resource. The <code>spec.terraform.enabled</code> set the repository as a terraform repository (as opposed to an opentofu repository). This setting will propagate to all layers linked to this repository by default, but can be overridden at the layer level.</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: burrito\n  namespace: &lt;tenant-namespace&gt;\nspec:\n  repository:\n    url: &lt;https-or-ssh-repository-url&gt;\n    secretName: burrito-repo\n  terraform:\n    enabled: true\n</code></pre> <p>Info</p> <p>You can also connect to a public repository by omitting <code>spec.repository.secretName</code> in your <code>TerraformRepository</code> definition.</p>"},{"location":"getting-started/#3-synchronize-a-terraform-layer","title":"3. Synchronize a terraform layer","text":"<p>After creating a <code>TerraformRepository</code> you can create a <code>TerraformLayer</code> ressource which looks like:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets\n  namespace: burrito\nspec:\n  terraform:\n    version: \"1.3.1\"\n  path: \"internal/e2e/testdata/terraform/random-pets\"\n  branch: \"main\"\n  repository:\n    name: burrito\n    namespace: burrito\n</code></pre> <p>The controller will create a runner pod in your tenant namespace to synchronize the repository and apply the terraform code.</p>"},{"location":"getting-started/#guides","title":"Guides","text":"<ul> <li>For detailed guides on how to use Burrito, see the Guides section.</li> <li>To learn more about advanced configuration and features, see the Operator Manual section.</li> </ul>"},{"location":"overview/","title":"Overview","text":""},{"location":"overview/#what-is-burrito","title":"What is burrito?","text":"<p>Burrito is a TACoS (Terraform Automation Collaboration Software) Kubernetes Operator.</p> <p>Burrito is designed to help you manage and automate your infrastructure as code in a Kubernetes-native way. In simple terms, it aims at being the ArgoCD for Infrastructure as Code.</p> <p></p>"},{"location":"overview/#why-burrito","title":"Why burrito?","text":"<p><code>terraform</code> is a tremendous tool to manage your infrastructure in IaC. However, it lacks built-in solutions for</p> <ul> <li>Managing state drift.</li> <li>Continuous planning and applying of your Terraform code</li> <li>Easy navigation of Terraform state</li> </ul>"},{"location":"overview/#state-drift","title":"State drift","text":"<p>Burrito provides a way to continuously plan your Terraform code and apply it . This way, you can ensure that your infrastructure is always up to date with your code, or at least be aware of the drift. This is especially useful when you have multiple people working on the same Terraform codebase. Burrito will help you detect drifts and resolve them before they become a problem.</p>"},{"location":"overview/#continuous-planning-and-applying","title":"Continuous planning and applying","text":"<p>Configuring a CI/CD pipeline for Terraform can be challenging because it often varies depending on the selected tools. Burrito offers an out-of-the-box PR/MR integration, so you don't have to write CI/CD pipelines for Terraform ever again. This ensures that you won't have to deal with:</p> <ul> <li>Managing state locks</li> <li>Managing Terraform versions</li> <li>Saving Terraform plan logs and results</li> <li>Integrating auditing tools (like Checkov)</li> </ul> <p>When a PR/MR is opened, Burrito will automatically plan the Terraform code and comment the MR/PR with the plan. This way, you can easily see the impact of the changes before applying them. Once the PR/MR is merged, Burrito will apply the Terraform code.</p>"},{"location":"overview/#navigation-of-your-terraform-state","title":"Navigation of your Terraform state","text":"<p>With its curated UI, Burrito provides a way to easily navigate your Terraform state, see the resources, and their dependencies. This way, you can easily see the impact of a change before applying it. [Not yet implemented]</p>"},{"location":"overview/#compatibility","title":"Compatibility","text":"<p>Burrito is compatible with:</p> <ul> <li>Terraform</li> <li>Terragrunt</li> <li>OpenTofu (coming soon)</li> </ul>"},{"location":"overview/#getting-started","title":"Getting started","text":"<ul> <li>Follow the getting started section to quickly set up Burrito and start monitoring Terraform state drift.  </li> <li>Follow the guides for detailed tutorials on how to use Burrito.  </li> <li>Deep dive into the operator manual to setup advanced configurations and features.</li> <li>Use the user guide to learn how to configure Burrito resources according to your needs.</li> </ul>"},{"location":"guides/","title":"Getting started","text":"<p>Follow the 3 guides below to understand how to use Burrito: </p> <ul> <li>IaC Drift detection: Quickly set up Burrito and start monitoring Terraform state drift.</li> <li>PR/MR plan/apply Workflow: Configure Burrito to automatically plan and apply Terraform code on PR/MR.</li> <li>UI Overview: Learn how to navigate the Burrito UI.</li> </ul>"},{"location":"guides/iac-drift-detection/","title":"Burrito Drift Detection","text":"<p>Drift detection is the core feature of Burrito. It allows you to monitor the drift between your Terraform state and your infrastructure in real-time. Burrito continuously plans your Terraform code by launching runner pods that will download the Terraform code, plan it, and store the result in its datastore.</p>"},{"location":"guides/iac-drift-detection/#exercise","title":"Exercise","text":"<p>Follow the steps below to set up Burrito on a local cluster and start planning your Terraform code automatically.</p>"},{"location":"guides/iac-drift-detection/#requirements","title":"Requirements","text":"<ul> <li>A Kubernetes cluster (you can use kind for a local cluster)</li> <li>Helm CLI</li> <li>kubectl CLI</li> </ul>"},{"location":"guides/iac-drift-detection/#install-burrito","title":"Install Burrito","text":"<p>Install Burrito with Helm as described in the installation guide, using the provided values file.</p> <pre><code>helm upgrade --install burrito oci://ghcr.io/padok-team/charts/burrito -n burrito-system -f https://raw.githubusercontent.com/padok-team/burrito/main/docs/examples/values-simple.yaml\n</code></pre> <p>With this command, you installed burrito with the following configuration:</p> <pre><code>config:\n  burrito:\n    controller:\n      timers:\n        driftDetection: 10m # run drift detection every 10 minutes\n        onError: 10s # wait 10 seconds before retrying on error\n        waitAction: 1m # wait 1 minute before retrying on locked layer\n        failureGracePeriod: 30s # set a grace period of 30 seconds before retrying on failure (increases exponentially with the amount of failed retries)\n    datastore:\n      storage:\n        mock: true # use a mock storage for the datastore (useful for testing, not recommended for production)\ntenants:\n  - namespace:\n      create: true\n      name: \"burrito-project\"\n</code></pre> <p>Burrito should be up and running in the <code>burrito-system</code> namespace.</p> <pre><code>kubectl get pods -n burrito-system\n</code></pre> <p>Output: <pre><code>NAME                                   READY   STATUS    RESTARTS   AGE\nburrito-controllers-6945797c5d-kjfl2   1/1     Running   0          2m00s\nburrito-datastore-94d999f54-kbg9z      1/1     Running   0          2m00s\nburrito-server-764f75766b-qw5nx        1/1     Running   0          2m00s\n</code></pre></p>"},{"location":"guides/iac-drift-detection/#connect-burrito-to-terraform-code-on-github","title":"Connect Burrito to Terraform code on GitHub","text":"<p>You will use the example Terraform code that we have prepared for you. This repository contains simple Terraform and Terragrunt with local random-pets resources that you can use to test Burrito.</p> <p>Create a TerraformRepository resource in the <code>burrito-system</code> namespace:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/padok-team/burrito/main/docs/examples/terraform-repository.yaml\n</code></pre> <p>Here is the content of the <code>TerraformRepository</code> resource that you have created. It references the GitHub repository containing the Terraform code. It also specifies that the IaC is Terraform code (as opposed to OpenTofu code). This setting will propagate to all layers linked to this repository by default, but can be overridden at the layer level.</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: my-repository\n  namespace: burrito-project\nspec:\n  repository:\n    url: https://github.com/padok-team/burrito-examples\n  terraform:\n    enabled: true\n</code></pre> <p>Create a <code>TerraformLayer</code> resource in the <code>burrito-system</code> namespace, referencing the <code>TerraformRepository</code> you just created. For now, the <code>autoApply</code> is set to false, so the layer will only plan the Terraform code and not apply it. </p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/padok-team/burrito/main/docs/examples/terraform-layer.yaml\n</code></pre> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: my-layer\n  namespace: burrito-project\nspec:\n  branch: main\n  path: terraform\n  remediationStrategy:\n    autoApply: false\n  repository:\n    name: my-repository\n    namespace: burrito-project\n</code></pre> <p>Check that your Terraform code is being planned by Burrito:</p> <pre><code>kubectl get pods -n burrito-project\n</code></pre> <p>Output:</p> <pre><code>NAME                   READY   STATUS      RESTARTS   AGE\nmy-layer-apply-xntrg   0/1     Completed   0          82s\n</code></pre> <p>The <code>TerraformLayer</code> should have been updated with the result of the plan. You can check the status of the <code>TerraformLayer</code> directly by querying the <code>TerraformLayer</code> resource, or by checking the burrito UI.</p> <pre><code>kubectl get tfl -n burrito-project\n</code></pre> <p>Output:</p> <pre><code>NAME       STATE         REPOSITORY      BRANCH   PATH        LAST RESULT\nmy-layer   ApplyNeeded   my-repository   main     terraform   Plan: 3 to create, 0 to update, 0 to delete\n</code></pre> <pre><code>kubectl port-forward svc/burrito-server -n burrito-system 8080:80\n</code></pre> <p></p> <p>Activate the <code>autoApply</code> feature by updating the <code>TerraformLayer</code> resource:</p> <pre><code>kubectl patch tfl my-layer -n burrito-project --type merge --patch '{\"spec\":{\"remediationStrategy\":{\"autoApply\":true}}}'\n</code></pre> <p>Check that the Terraform code was applied:</p> <pre><code>kubectl get pods -n burrito-project\n</code></pre> <p>Output:</p> <pre><code>NAME                   READY   STATUS      RESTARTS   AGE\nmy-layer-apply-bxlcr   0/1     Completed   0          54s\nmy-layer-plan-jv86k    0/1     Completed   0          7m22s\n</code></pre> <pre><code>kubectl get tfl -n burrito-project\n</code></pre> <p>Output:</p> <pre><code>NAME       STATE   REPOSITORY      BRANCH   PATH        LAST RESULT\nmy-layer   Idle    my-repository   main     terraform   Apply Successful\n</code></pre>"},{"location":"guides/iac-drift-detection/#conclusion","title":"Conclusion","text":"<p>You have successfully set up Burrito on a local cluster and planned your Terraform code automatically. You can now monitor the drift between your Terraform state and your infrastructure in real-time.</p>"},{"location":"guides/iac-drift-detection/#next-steps","title":"Next steps","text":"<ul> <li>Learn how to configure a PR/MR workflow</li> </ul>"},{"location":"guides/pr-mr-workflow/","title":"PR/MR workflow","text":"<p>Now that you have set up Burrito and planned your Terraform code automatically, you can configure a PR/MR workflow to never have to use the <code>terraform apply</code> command ever again.</p>"},{"location":"guides/pr-mr-workflow/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>You have set up Burrito on a cluster.</li> <li>You set up TerraformRepository and TerraformLayer resources to plan your Terraform code automatically.</li> </ul>"},{"location":"guides/pr-mr-workflow/#setup-a-webhook-and-github-app-for-your-repository","title":"Setup a webhook and GitHub app for your repository","text":"<p>To trigger the Burrito plan and apply workflow, you need to set up a webhook from your repository to your Burrito instance. Fork the burrito-examples repository and update the <code>TerraformRepository</code> resource to point to your forked repository.</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: my-repository\n  namespace: burrito-project\nspec:\n  repository:\n    url: https://github.com/&lt;your-github-handle&gt;/burrito-examples\n  terraform:\n    enabled: true\n</code></pre> <p>You will also need to setup a GitHub App to allow Burrito to comment on your PRs/MRs. Follow the instructions in the PR/MR workflow section of the operator manual to set up the GitHub app. Make sure that you updated the Burrito values file to include the GitHub app ID, installation ID, and private key to the Burrito controller deployment.</p> <p>Info</p> <p>Your controller deployment should now have the following environment variables: - <code>BURRITO_CONTROLLER_GITHUBCONFIG_APPID</code>: The App ID of your GitHub app. - <code>BURRITO_CONTROLLER_GITHUBCONFIG_INSTALLATIONID</code>: The Installation ID of your GitHub app. - <code>BURRITO_CONTROLLER_GITHUBCONFIG_PRIVATEKEY</code>: The private key of your GitHub app.  </p> <p>Note</p> <p>You can also use a personal access token instead of a GitHub app. Your GitHub account will be used to comment on the PRs/MRs. The environment variable to set is <code>BURRITO_CONTROLLER_GITHUBCONFIG_APITOKEN</code></p> <p>Now let's configure the GitHub webhook. Expose the <code>burrito-server</code> kubernetes service to the internet using the method of your choice. (for testing purposes on a local cluster, you can use <code>kubectl port-forward</code> and ngrok to expose the service to the internet).</p> <p>Configure a webhook in your GitHub repository to point to the exposed <code>burrito-server</code> service. Make sure to specify the <code>/api/webhook</code> path in the target url. The webhook should be triggered on <code>push</code> and <code>pull_request</code> events. You can reference your webhook secret in a secret named <code>burrito-webhook-secret</code> in the controller namespace (<code>burrito-system</code> in this tutorial).</p> <pre><code>kind: Secret\nmetadata:\n  name: burrito-webhook-secret\n  namespace: burrito-system\ntype: Opaque\nstringData:\n  burrito-webhook-secret: &lt;my-webhook-secret&gt;\n</code></pre> <p>You can also directly add the webhook secret as an environment variable of the <code>burrito-server</code> deployment. The variable name depends on your git provider. For GitHub, the environment variable is <code>BURRITO_SERVER_WEBHOOK_GITHUB_SECRET</code>.</p>"},{"location":"guides/pr-mr-workflow/#experiment-with-the-prmr-workflow","title":"Experiment with the PR/MR workflow","text":"<p>Now that you have set up the webhook and GitHub app, you can experiment with the PR/MR workflow. Create a new branch in your forked repository and make some changes to the Terraform code. Push the changes to the branch and open a PR/MR against the main branch.</p> <p>A new TerraformPullRequest resource should be created in your tenant namespace. You can check the status of the resource by running:</p> <pre><code>kubectl get pr -n burrito-project\n</code></pre> <p>Output:</p> <pre><code>NAME              ID    STATE   PROVIDER   BASE   BRANCH\nmy-repository-1   1     Idle    github     main   update-tf-code\n</code></pre> <p>A new TerraformLayer resource should also be created to plan the Terraform code. You can check the status of the resource by running:</p> <pre><code>kubectl get tfl -n burrito-project\n</code></pre> <p>Output:</p> <pre><code>NAME                  STATE         REPOSITORY      BRANCH           PATH        LAST RESULT\nmy-layer              ApplyNeeded   my-repository   main             terraform   Plan: 3 to create, 0 to update, 0 to delete\nmy-layer-pr-1-rxvrt   ApplyNeeded   my-repository   update-tf-code   terraform   Plan: 2 to create, 0 to update, 0 to delete\n</code></pre> <p>The Burrito server should have commented on the PR/MR with the plan output. You can check the comments on the PR/MR to see the plan output.</p> <p></p> <p>Set the <code>autoApply</code> field to <code>true</code> in the TerraformLayer resource to automatically apply the Terraform code upon merging the PR/MR.</p>"},{"location":"guides/pr-mr-workflow/#conclusion","title":"Conclusion","text":"<p>You have now set up a PR/MR workflow with Burrito to automatically plan and apply your Terraform code. You can now focus on writing Terraform code and let Burrito handle the rest.</p>"},{"location":"guides/pr-mr-workflow/#next-steps","title":"Next steps","text":"<ul> <li>Navigate the Burrito UI to see the status of the Terraform resources.</li> </ul>"},{"location":"guides/ui/","title":"UI Overview","text":"<p>The Burrito UI is a web-based interface that allows you to view the state of your Terraform layers and resources, as well as the drift between the desired and actual state of your infrastructure.</p>"},{"location":"guides/ui/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>A running Burrito installation</li> </ul>"},{"location":"guides/ui/#accessing-the-ui","title":"Accessing the UI","text":"<p>The Burrito UI is accessible via a web browser. To access the UI, you need to expose the <code>burrito-server</code> service locally or on a public URL.</p>"},{"location":"guides/ui/#features","title":"Features","text":""},{"location":"guides/ui/#homepage","title":"Homepage","text":"<p>The homepage displays a list of all the Terraform layers that have been added to Burrito. Each layer is displayed as a card with the following information:</p> <ul> <li>Namespace</li> <li>Repository</li> <li>Branch</li> <li>Code path</li> <li>Last plan result</li> <li>State (Error, Out-of-sync, OK)</li> </ul> <p></p>"},{"location":"guides/ui/#terraform-terragrunt-logs","title":"Terraform / Terragrunt logs","text":"<p>Click on the layer card to view the Terraform or Terragrunt logs for that layer. You can explore previous runs and view the logs for each run. The maximum number of logs to keep is configurable. </p> <p>A dedicated page for exploring the logs is also available.</p>"},{"location":"guides/ui/#more-to-come","title":"More to come","text":"<p>Burrito is under active development, and we are working on adding more features to the UI such as:</p> <ul> <li>\"Plan and apply\" buttons</li> <li>Notifications</li> <li>User management</li> <li>Pull request view   ... and more!</li> </ul>"},{"location":"installation/with-helm/","title":"Install burrito with Helm","text":""},{"location":"installation/with-helm/#requirements","title":"Requirements","text":"<ul> <li>Installed kubectl command-line tool</li> <li>Installed helm command-line tool (version v3.8.0 and further)</li> <li>Have access to a Kubernetes cluster</li> </ul>"},{"location":"installation/with-helm/#1-basic-installation","title":"1. Basic installation","text":"<p>Info</p> <p>Our Helm chart is published in an OCI-based registry (ghcr.io). You must use Helm v3.8.0 or above.</p> <pre><code>helm install burrito oci://ghcr.io/padok-team/charts/burrito -n burrito-system --create-namespace\n</code></pre> <p>This will create a new namespace, <code>burrito-system</code>, where the burrito core components will live.</p> <p>You can change the chart's version with any version available on our Chart registry.</p>"},{"location":"installation/with-helm/#2-burrito-helm-configuration","title":"2. Burrito Helm configuration","text":"<p>The Burrito configuration is managed through Helm values files, which can be overridden at installation time.</p> <p>You can find the default values of the Burrito Helm chart by running:</p> <pre><code>helm show values oci://ghcr.io/padok-team/charts/burrito\n</code></pre> <p>The source code and values file of the chart is available on burrito GitHub repository.</p> <p>Here is an example of a simple burrito Helm values file that you can use to bootstrap your installation:</p> <pre><code>config:\n  burrito:\n    controller:\n      timers:\n        driftDetection: 10m # run drift detection every 10 minutes\n        onError: 10s # wait 10 seconds before retrying on error\n        waitAction: 1m # wait 1 minute before retrying on locked layer\n        failureGracePeriod: 30s # set a grace period of 30 seconds before retrying on failure (increases exponentially with the amount of failed retries)\n    datastore:\n      storage:\n        mock: true # use a mock storage for the datastore (useful for testing, not recommended for production)\ntenants:\n  - namespace:\n      create: true\n      name: \"burrito-project\"\n    serviceAccounts:\n    - name: burrito-runner\n      annotations:\n        iam.gke.io/gcp-service-account: burrito@company-project.iam.gserviceaccount.com # example: use GKE Workload Identity to have access to GCP infrastructure\n</code></pre> <p>Info</p> <p>Learn more about these values in the chart's README file and Multi-tenant architecture.</p>"},{"location":"installation/with-static-manifests/","title":"Install burrito with static manifests","text":""},{"location":"installation/with-static-manifests/#requirements","title":"Requirements","text":"<ul> <li>Installed kubectl command-line tool.</li> <li>Have a kubeconfig file (default location is <code>~/.kube/config</code>).</li> </ul>"},{"location":"installation/with-static-manifests/#install-burrito","title":"Install burrito","text":"<p>Info</p> <p>This will install a mono-tenant version of burrito. See the Helm installation method for a multi-tenant-architecture.</p> <pre><code>kubectl create namespace burrito\nkubectl apply -n burrito -f https://raw.githubusercontent.com/padok-team/burrito/main/manifests/install.yaml\n</code></pre> <p>This will create a new namespace, <code>burrito</code>, where burrito services will live.</p> <p>Warning</p> <p>The installation manifests include <code>ClusterRoleBinding</code> resources that reference <code>burrito</code> namespace. If you are installing burrito into a different namespace then make sure to update the namespace reference.</p>"},{"location":"operator-manual/","title":"Overview","text":"<p>This guide is for administrator and operator wanting to install and configure burrito for other developers.</p> <p>Note</p> <p>Please make sure you've completed the getting started guide.</p>"},{"location":"operator-manual/advanced-configuration/","title":"Advanced configuration","text":""},{"location":"operator-manual/advanced-configuration/#controllers-configuration","title":"Controllers' configuration","text":"Environment variable Description Default <code>BURRITO_CONTROLLER_NAMESPACES</code> list of namespaces to watch (comma-separated) <code>burrito-system</code> <code>BURRITO_CONTROLLER_TYPES</code> list of controllers to start <code>layer,repository,run,pullrequest</code> <code>BURRITO_CONTROLLER_TIMERS_DRIFTDETECTION</code> period between two plans for drift detection <code>20m</code> <code>BURRITO_CONTROLLER_TIMERS_ONERROR</code> period between two runners launch when an error occurred in the controllers <code>1m</code> <code>BURRITO_CONTROLLER_TIMERS_WAITACTION</code> period between two runners launch when a layer is locked <code>1m</code> <code>BURRITO_CONTROLLER_TIMERS_FAILUREGRACEPERIOD</code> initial time before retry, goes exponential function of number failure <code>15s</code> <code>BURRITO_CONTROLLER_TERRAFORMMAXRETRIES</code> default number of retries for terraform runs (can be overriden in CRDs) <code>5</code> <code>BURRITO_CONTROLLER_LEADERELECTION_ENABLED</code> whether leader election is enabled or not <code>true</code> <code>BURRITO_CONTROLLER_LEADERELECTION_ID</code> lease id used for leader election <code>6d185457.terraform.padok.cloud</code> <code>BURRITO_CONTROLLER_HEALTHPROBEBINDADDRESS</code> address to bind the health probe server embedded in the controllers <code>:8081</code> <code>BURRITO_CONTROLLER_METRICSBINDADDRESS</code> address to bind the metrics server embedded in the controllers <code>:8080</code> <code>BURRITO_CONTROLLER_KUBERNETESWEBHOOKPORT</code> port used by the validating webhook server embedded in the controllers <code>9443</code>"},{"location":"operator-manual/advanced-configuration/#servers-configuration","title":"Server's configuration","text":"Environment variable Description Default <code>BURRITO_SERVER_ADDR</code> address the server listens on <code>:8080</code> <p>Info</p> <p>For webhook configuration see Setup a git webhook.</p>"},{"location":"operator-manual/advanced-configuration/#runners-configuration","title":"Runners' configuration","text":"<p>Currently, runners' configuration is not exposed.</p> <p>Info</p> <p>You can override some of the runner's pod spec. See override the runner pod spec documentation.</p>"},{"location":"operator-manual/architecture/","title":"Architectural Overview","text":""},{"location":"operator-manual/architecture/#components","title":"Components","text":""},{"location":"operator-manual/architecture/#the-server","title":"The server","text":"<p>The server is a REST server which exposes the API consumed by the Web UI. It has the following responsibilities:</p> <ul> <li>listener for Git webhook events</li> </ul> <p>Other features will be implemented when the Web UI will be in development.</p>"},{"location":"operator-manual/architecture/#the-repository-controller","title":"The repository Controller","text":"<p>The repository controller is a Kubernetes Controller which is only used to register <code>TerraformRepository</code> resources.</p>"},{"location":"operator-manual/architecture/#the-layer-controller","title":"The layer Controller","text":"<p>The layer controller is a Kubernetes Controller which continuously monitors declared <code>TerraformLayer</code> resources. It regurlarly creates <code>TerraformRun</code> resources which run a <code>terraform plan</code> for each of your layer to check if a drift has been introduced. If so, it has the possibility to create a <code>TerraformRun</code> that does a <code>terraform apply</code>.</p> <p>It is also responsible for running your Terraform <code>plan</code> and <code>apply</code> if there is a new commit on your layer.</p>"},{"location":"operator-manual/architecture/#the-run-controller","title":"The run Controller","text":"<p>The run controller is a Kubernetes Controller which continuously monitors declared <code>TerraformRun</code> resources.</p> <p>It is responsible for running the <code>terraform plan</code> and <code>terraform apply</code> commands by creating runner pods. It handles failure and retries of the runner pods.</p> <p>It also generates <code>Leases</code> to make sure no concurrent terraform commands will be launched on the same layer at the same time.</p>"},{"location":"operator-manual/architecture/#the-datastore-instance","title":"The Datastore instance","text":"<p>The Datastore instance of Burrito is a http proxy that provides download/upload capabilities to the runners. It is used to store the Terraform plan files generated by the runners and to store the associated logs.</p>"},{"location":"operator-manual/architecture/#implementation","title":"Implementation","text":"<p>The operator has been bootstrapped using the <code>operator-sdk</code>.</p> <p>The CLI used to start the different components is implemented using <code>cobra</code>.</p>"},{"location":"operator-manual/architecture/#the-terraformlayer-controller","title":"The TerraformLayer Controller","text":"<p>The status of a <code>TerraformLayer</code> is defined using the conditions standards defined by the community.</p> <p>3 conditions are defined for a layer:</p> <ul> <li><code>IsPlanArtifactUpToDate</code>. This condition is used for drift detection. The evaluation is made by compraing the timestamp of the last <code>terraform plan</code> which ran and the current date. The timestamp of the last plan is \"stored\" using an annotation.</li> <li><code>IsApplyUpToDate</code>. This condition is used to check if an <code>apply</code> needs to run after the last <code>plan</code>. Comparison is made by comparing a checksum of the last planned binary and a checksum last applied binary stored in the annotations.</li> <li><code>IsLastRelevantCommitPlanned</code>. This condition is used to check if a new commit has been made to the layer and need to be applied. It is evaluated by comparing the commit used for the last <code>plan</code>, the last commit which intoduced changes to the layer and the last commit made to the same branch of the repository. Those commits are \"stored\" as annotations.</li> </ul> <p>With those 3 conditions, we defined 3 states:</p> <ul> <li><code>Idle</code>. This is the state of a layer if no runner needs be started</li> <li><code>PlanNeeded</code>. This is the state of a layer if burrito needs to start a <code>plan</code> runner</li> <li><code>ApplyNeeded</code>. This is the state of a layer if burrito needs to start an <code>apply</code> runner</li> </ul> <p>Info</p> <p>If you use <code>dry</code> remediation strategy and an apply is needed, the layer will stay in the <code>ApplyNeeded</code> as long as it does not need to enter the <code>PlanNeeded</code>.</p>"},{"location":"operator-manual/architecture/#the-terraformrun-controller","title":"The TerraformRun Controller","text":"<p>The status of a <code>TerraformRun</code> is also defined using the same conditions standards defined by the community.</p> <p>5 conditions are defined for a run:</p> <ul> <li><code>HasStatus</code>. This condition is used to check if a <code>TerraformRun</code> has already been reconciled by the controller.</li> <li><code>HasReachedRetryLimit</code>. Used to check if a <code>TerraformRun</code> has reached the maximum number of retries.</li> <li><code>HasSucceeded</code>. Used to check if a <code>TerraformRun</code> has already succeeded (runner pod exited successfully).</li> <li><code>IsRunning</code>. Used to check if a <code>TerraformRun</code> is currently running by checking the current phase of its associated pod.</li> <li><code>IsInfailureGracePeriod</code>. This condition is used to check if a Terraform workflow has already failed. If so, we use an exponential backoff strategy before restarting a runner on the given layer.</li> </ul> <p>With those 5 conditions, we defined 6 states:</p> <ul> <li><code>Initial</code>. This is the state of a run when it has just been created and has launched its first runner pod.</li> <li><code>Running</code>. This is the state of a run if a runner pod is currently running.</li> <li><code>FailureGracePeriod</code>. This is the state of a layer if a <code>plan</code> or <code>apply</code> runner has failed</li> <li><code>Retrying</code>. This is an intermediate state of a run if a runner pod has failed and is being restarted (not in failure grace period anymore).</li> <li><code>Succeeded</code>. This is one of the two final states a run can have. It means that the runner pod has exited successfully.</li> <li><code>Failed</code>. This is the other final state a run can have. It means that the run has failed multiple times and has reached the maximum number of retries.</li> </ul> <p>The <code>TerraformRun</code> controller also creates and deletes the Kubernetes leases to avoid concurrent use of Terraform on the same layer.</p>"},{"location":"operator-manual/architecture/#the-runners","title":"The runners","text":"<p>The runner implementation relies on <code>tenv</code>, a tool from the community which allows us to dynamically download and use any version of Terraform, Terragrunt or OpenTofu (coming soon). Thus, we support any existing version of Terraform.</p> <p>If no version constraint is set in the TerraformLayer resource or in the TerraformRepository resource, <code>tenv</code> will detect which version of Terraform/Terragrunt/OpenTofu to use by looking at the version constraints in your code.</p> <p>The runner is responsible to update the annotations of the layer it is associated to to store information about what commit was planned/applied and when.</p>"},{"location":"operator-manual/datastore/","title":"Datastore","text":""},{"location":"operator-manual/datastore/#configuration","title":"Configuration","text":"<p>The Datastore storage backend can be configured using the following yaml configuration :</p> <pre><code>config:\n  burrito:\n    datastore:\n      storage:\n        mock: &lt;false|true&gt; # default: false\n        s3:\n          bucket: &lt;bucket-name&gt;\n          usePathStyle: &lt;false|true&gt; # default: false\n        gcs:\n          bucket: &lt;bucket-name&gt;\n        azure:\n          storageAccount: &lt;storage-account&gt;\n          container: &lt;container-name&gt;\n</code></pre> <p>Info</p> <p>Only one storage backend can be configured at a time.</p> <p>Warning</p> <p>The <code>mock</code> storage backend is only for testing purposes and should not be used in production. If enabled, Burrito will store the data in memory and will lose it when the pod is restarted. It also might fill up the memory of the pod if too much data is stored.</p>"},{"location":"operator-manual/datastore/#authentication","title":"Authentication","text":"<p>The different cloud provider implementations rely on the default credentials chain of the cloud provider SDKs. Use annotations and labels on the service account associated to the datastore by updating the <code>datastore.serviceAccount.metadata</code> field to specify the credentials to use. (e.g. <code>iam.amazonaws.com/role</code> for AWS)</p>"},{"location":"operator-manual/datastore/#authorization","title":"Authorization","text":"<p>The Datastore relies on TokenReview and mounted volumes for authorization. We rely on a custom audience for the TokenReview to ensure that the token can only be used for the Datastore.</p>"},{"location":"operator-manual/datastore/#object-expiration","title":"Object expiration","text":"<p>For now the datastore doesn't delete any object it puts into the storage backend. This is a feature that will be implemented in the future.</p>"},{"location":"operator-manual/git-webhook/","title":"Setup a Git Webhook","text":""},{"location":"operator-manual/git-webhook/#expose-burrito-server-to-the-internet","title":"Expose Burrito server to the internet","text":"<p>Expose the <code>burrito-server</code> service to the internet using the method of your choice. (e.g. ingress, port-forward &amp; ngrok for local testing...). Accessing the URL on the browser should display the Burrito UI.</p>"},{"location":"operator-manual/git-webhook/#configure-a-webhook-on-github-or-gitlab","title":"Configure a webhook on GitHub or GitLab","text":"<p>Create a webhook (with a secret!) in the repository you want to receive events from. The target URL must point to the exposed <code>burrito-server</code> on the <code>/api/webhook</code> path.</p> <p>GitHub triggers: The webhook should be triggered on <code>push</code> and <code>pull_request</code> events.</p> <p>GitLab triggers: The webhook should be triggered on <code>Push events</code> from all branches and <code>Merge request events</code>.</p>"},{"location":"operator-manual/git-webhook/#reference-the-webhook-secret-in-the-controller","title":"Reference the webhook secret in the controller","text":"<p>Create a secret called <code>burrito-webhook-secret</code> in the controller namespace with the webhook secret. <pre><code>kind: Secret\napiVersion: v1\nmetadata:\n  name: burrito-webhook-secret\n  namespace: burrito-system\ntype: Opaque\nstringData:\n  burrito-webhook-secret: &lt;my-webhook-secret&gt;\n</code></pre></p> <p>Add the webhook secret as an environment variable of the <code>burrito-server</code>. The variables depends on your git provider.</p> Git provider Environment Variable GitHub <code>BURRITO_SERVER_WEBHOOK_GITHUB_SECRET</code> GitLab <code>BURRITO_SERVER_WEBHOOK_GITLAB_SECRET</code>"},{"location":"operator-manual/multi-tenant-architecture/","title":"Multi-tenant architecture","text":"<p>With our Helm chart we provide a way to setup multi-tenancy with burrito. This is useful when working at scale, when you controls multiple Terraform projects with burrito across several teams.</p> <p>The setup is split across multiple Kubernetes namespaces:</p> <ul> <li><code>burrito-system</code> is where burrito's components live and operate (controllers, server, datastore)</li> <li>the other namespaces (<code>tenant-namespace-[1-3]</code> on the schema) where <code>TerraformRepository</code>, <code>TerraformLayer</code>, <code>TerraformRun</code> and <code>TerraformPullRequest</code> resources live and where burrito spawns runner pods for Terraform <code>plan</code> and <code>apply</code> actions.</li> </ul> <p>Thanks to Kubernetes native RBAC system you can restrict access for your users only to the namespaces their burrito resources live.</p>"},{"location":"operator-manual/multi-tenant-architecture/#configuring-multi-tenancy-with-the-helm-chart","title":"Configuring multi-tenancy with the Helm chart","text":""},{"location":"operator-manual/multi-tenant-architecture/#1-configure-basic-tenants","title":"1. Configure basic tenants","text":"<p>In the <code>values.yaml</code> of the Helm chart, add the following:</p> <pre><code>tenants:\n  - namespace:\n      create: true\n      name: tenant-namespace-1\n    serviceAccounts:\n      - name: runner-project\n  - namespace:\n      create: true\n      name: tenant-namespace-2\n    serviceAccounts:\n      - name: runner-project\n  - namespace:\n      create: true\n      name: tenant-namespace-3\n    serviceAccounts:\n      - name: runner-project\n</code></pre> <p>This setup creates 3 tenants with 3 namespaces with one service account in each namespace.</p> <p>The chart adds every tenant referenced in its values in the namespaces that the burrito controllers must watch.</p> <p>You can also customize namespaces' labels and annotations:</p> <pre><code>tenants:\n  - namespace:\n      create: true\n      name: tenant-namespace-1\n      labels:\n        app.kubernetes.io/part-of: project-1\n      annotations:\n        helm.sh/resource-policy: keep\n</code></pre>"},{"location":"operator-manual/multi-tenant-architecture/#2-configure-service-accounts","title":"2. Configure service accounts","text":"<p>Each service account created in a tenant is bound to the <code>burrito-runner</code> ClusterRole, it is a basic role with the required permissions for a burrito runner pod to work properly.</p> <p>You can add additional role bindings to the service accounts if you need special permissions in the cluster (e.g. a Terraform layer deploying to Kubernetes) as well as annotations and labels (e.g. assume a role on a cloud provider).</p> <pre><code>  - namespace:\n      create: true\n      name: tenant-namespace-1\n    serviceAccounts:\n      - name: runner-kubernetes\n        additionalRoleBindings:\n          - name: custom\n            role:\n              kind: ClusterRole\n              name: custom-role\n      - name: runner-google\n        labels:\n          app.kubernetes.io/part-of: project-1\n        annotations:\n          iam.gke.io/gcp-service-account: burrito-project-1@company-project.iam.gserviceaccount.com\n      - name: runner-aws\n        annotations:\n          eks.amazonaws.com/role-arn: arn:aws:iam::111122223333:role/my-role\n</code></pre>"},{"location":"operator-manual/multi-tenant-architecture/#3-use-service-accounts-in-the-tenant","title":"3. Use service accounts in the tenant","text":"<p>For the <code>TerraformRepository</code> or <code>TerraformLayer</code> you deploy in a tenant, you can use the <code>overrideRunnerSpec</code> parameter to select which service account to use for runners affected to a layer/repository.</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: infra-aws\n  namespace: tenant-namespace-1\nspec:\n  terraform:\n    version: \"1.5.3\"\n  path: \"infra/layers/aws/production\"\n  branch: \"main\"\n  repository:\n    name: project-1\n    namespace: tenant-namespace-1\n  overrideRunnerSpec:\n    serviceAccountName: runner-aws # &lt;-- Specify service account here\n</code></pre>"},{"location":"operator-manual/pr-mr-workflow/","title":"PR/MR Workflow","text":"<p>Info</p> <p>In this documentation all references to pull requests can be change to merge requests for GitLab. However, the resulting Kubernetes object will still be named <code>TerraformPullRequest</code>.</p>"},{"location":"operator-manual/pr-mr-workflow/#components","title":"Components","text":""},{"location":"operator-manual/pr-mr-workflow/#the-server","title":"The server","text":"<p>Info</p> <p>For more information about the server, see the architectural overview documentation.</p> <p>Upon receiving a Pull Request creation event, the server creates a <code>TerraformPullRequest</code> resource.</p> <p>Upon receiving a Pull Request deletion event, the server deletes the related <code>TerraformPullRequest</code> resource.</p>"},{"location":"operator-manual/pr-mr-workflow/#the-pull-request-controller","title":"The pull request controller","text":"<p>The pull request controller is a Kubernetes controller which continuously monitors declared <code>TerraformPullRequest</code> resources.</p> <p>It is responsible for creating temporary <code>TerraformLayer</code> resources linked to the Pull Request it was generated from. Once all the <code>TerraformLayer</code> have planned, it will send a comment containing the plan results to the pull request.</p> <p></p>"},{"location":"operator-manual/pr-mr-workflow/#implementation","title":"Implementation","text":"<p>The status of a <code>TerraformPulLRequest</code> is defined using the conditions standards defined by the community.</p> <p>3 conditions ared defined for a pull request:</p> <ul> <li><code>IsLastCommitDiscovered</code>. This condition is used to check if we received a new commit on the pull request by comparing the latest commit on the branch and the last discovered commit.</li> <li><code>AreLayersStillPlanning</code>. This condition is used to check if all the temporary layers have finished planning. This is done by checking all the resulting <code>TerraformLayer</code> statuses.</li> <li><code>IsCommentUpToDate</code>. This condition is used to check if the controller needs to send a comment to a pull request. This is checked by comparing the last discovered commit and the last commit for which a comment was already sent.</li> </ul> <p>Info</p> <p>We use annotations to store information.</p> <p>With those 3 conditions, we defined 3 states:</p> <ul> <li><code>Idle</code>. This is the state of a pull request if nothing needs to be done.</li> <li><code>DiscoveryNeeded</code>. This is the state of a pull request if the controller needs to check which layers are affected on the given pull request.</li> <li><code>CommentNeeded</code>. This is the state of a pull request if the controller needs to send a comment to the git provider's API.</li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#configuration","title":"Configuration","text":""},{"location":"operator-manual/pr-mr-workflow/#webhook","title":"Webhook","text":"<p>Follow the instructions in Setting up a Git Webhook to configure a webhook in your repository. The webhook will be used to trigger: - Drift detection when a push event is received. - The PR/MR workflow when a pull request event is received.</p>"},{"location":"operator-manual/pr-mr-workflow/#github-with-a-dedicated-github-app","title":"GitHub with a dedicated GitHub App","text":""},{"location":"operator-manual/pr-mr-workflow/#create-the-github-app","title":"Create the GitHub App","text":"<p>You can create and register GitHub Apps in your personal GitHub account or in any GitHub organization where you have administrative access.</p> <p>Follow the instructions in the GitHub documentation on Creating a GitHub App. Populate the settings as follows:</p> <ul> <li>GitHub App Name: Choose a name for your GitHub App. For example, something featuring <code>burrito</code>.</li> <li>Homepage URL: Enter https://padok-team.github.io/burrito.</li> <li>Webhook: Deselect Active. The app doesn't use this webhook events mechanism at the moment.</li> <li>Permissions: Configure the following Repository Permissions.</li> <li>Metadata: Select Read-only.</li> <li>Pull requests: Select Read &amp; write. This is required to issue comments on pull requests.</li> <li>Where can this GitHub App be installed: Select Any account.</li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#creating-a-custom-badge-for-your-github-app","title":"Creating a custom badge for your GitHub App","text":"<p>You can create a custom badge for your GitHub App to display on your GitHub repository. Follow the instructions in the GitHub documentation on Creating a custom badge for your GitHub App.</p> <p>We suggest using the following one:</p> <p></p>"},{"location":"operator-manual/pr-mr-workflow/#install-the-github-app","title":"Install the GitHub App","text":"<p>Follow the instructions in the GitHub documentation on Installing your own GitHub App, and note the following:</p> <ul> <li>For Repository access, select Only select repositories, and then select the repos you want to connect with Burrito.</li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#get-the-installation-id-and-app-id","title":"Get the Installation ID and App ID","text":"<p>You need the Installation ID and App ID to configure Burrito.</p> <ol> <li>Get the Installation ID from the URL of the installed app, such as:</li> </ol> <p></p> <ol> <li>Get the App ID from the app's General tab.</li> </ol> <p></p>"},{"location":"operator-manual/pr-mr-workflow/#generate-a-private-key","title":"Generate a private key","text":"<p>You need a private key for your GitHub app to configure Burrito.</p> <ul> <li> <p>Follow the instructions in the GitHub documentation for generating private keys for GitHub Apps</p> </li> <li> <p>Save the private key file to your local machine. GitHub only stores the public portion of the key.</p> </li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#configure-burrito","title":"Configure Burrito","text":"<p>Add the following environment variables to your Burrito controller deployment:</p> <ul> <li><code>BURRITO_CONTROLLER_GITHUBCONFIG_APPID</code>: The App ID of your GitHub app.</li> <li><code>BURRITO_CONTROLLER_GITHUBCONFIG_INSTALLATIONID</code>: The Installation ID of your GitHub app.</li> <li><code>BURRITO_CONTROLLER_GITHUBCONFIG_PRIVATEKEY</code>: The private key of your GitHub app.</li> </ul> <p>For example:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: burrito-github-config\n  namespace: burrito\ntype: Opaque\nstringData:\n  BURRITO_CONTROLLER_GITHUBCONFIG_APPID: \"123456\"\n  BURRITO_CONTROLLER_GITHUBCONFIG_INSTALLATIONID: \"12345678\"\n  BURRITO_CONTROLLER_GITHUBCONFIG_PRIVATEKEY: |\n    -----BEGIN RSA PRIVATE KEY-----\n    ...\n    -----END RSA PRIVATE KEY-----\n</code></pre>"},{"location":"operator-manual/pr-mr-workflow/#github-with-a-personal-access-token","title":"GitHub with a personal access token","text":""},{"location":"operator-manual/pr-mr-workflow/#generate-a-personal-access-token","title":"Generate a personal access token","text":"<p>You need a personal access token to configure Burrito. You can generate a personal access token in your GitHub account.</p> <p>Follow the instructions in the GitHub documentation for creating a personal access token:</p> <ul> <li>It should be a fine-grained token.</li> <li>Permissions: Configure the following Repository Permissions.</li> <li>Metadata: Select Read-only.</li> <li>Pull requests: Select Read &amp; write. This is required to issue comments on pull requests.</li> <li>Under Repository access, select which repositories you want the token to access.</li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#configure-burrito_1","title":"Configure Burrito","text":"<p>Add the following environment variables to your Burrito controller deployment:</p> <ul> <li><code>BURRITO_CONTROLLER_GITHUBCONFIG_APITOKEN</code>: The personal access token of your GitHub app.</li> </ul> <p>For example:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: burrito-github-config\n  namespace: burrito\ntype: Opaque\nstringData:\n  BURRITO_CONTROLLER_GITHUBCONFIG_APITOKEN: github_pat_123456\n</code></pre>"},{"location":"operator-manual/pr-mr-workflow/#gitlab","title":"GitLab","text":""},{"location":"operator-manual/pr-mr-workflow/#generate-a-private-token","title":"Generate a private token","text":"<p>You need a private token for your GitLab app to configure Burrito. You can generate a private token in your GitLab account. Follow the instructions in the GitLab documentation for generating a private token.</p>"},{"location":"operator-manual/pr-mr-workflow/#configure-burrito_2","title":"Configure Burrito","text":"<p>Add the following environment variables to your Burrito controller deployment:</p> <ul> <li><code>BURRITO_CONTROLLER_GITLABCONFIG_APITOKEN</code>: The private token of your GitLab app.</li> <li><code>BURRITO_CONTROLLER_GITLABCONFIG_URL</code>: The URL of your GitLab instance.</li> </ul> <p>For example:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: burrito-gitlab-config\n  namespace: burrito\ntype: Opaque\nstringData:\n  BURRITO_CONTROLLER_GITLABCONFIG_APITOKEN: \"123456\"\n  BURRITO_CONTROLLER_GITLABCONFIG_URL: \"https://gitlab.example.com\"\n</code></pre> Environment variable Description <code>BURRITO_CONTROLLER_GITHUBCONFIG_APPID</code> the GtiHub App ID to send comment to GitHub's API <code>BURRITO_CONTROLLER_GITHUBCONFIG_INSTALLATIONID</code> the GitHub Installation ID to send comment to GitHub's API <code>BURRITO_CONTROLLER_GITHUBCONFIG_PRIVATEKEY</code> the GitHub App private key to send comment to GitHub's API <code>BURRITO_CONTROLLER_GITHUBCONFIG_APITOKEN</code> the API token to send comment to GitHub's API <code>BURRITO_CONTROLLER_GITLABCONFIG_APITOKEN</code> the API token to send comment to GitLab's API <code>BURRITO_CONTROLLER_GITLABCONFIG_URL</code> the URL of the GitLab instance"},{"location":"operator-manual/provider-caching/","title":"Caching Terraform Providers","text":"<p>By caching Terraform providers, Burrito can avoid downloading them from outside the cluster every time a runner initializes a Terraform layer. This can significantly reduce the ingress traffic to the infrastructure running Burrito.</p> <p>The Burrito Helm chart is packaged with Hermitcrab, which leverages the Provider Network Mirror Protocol from Terraform to cache providers.</p>"},{"location":"operator-manual/provider-caching/#1-activate-hermitcrab-on-burrito","title":"1. Activate Hermitcrab on Burrito","text":"<p>Hermitcrab is available to use with Burrito when using the Helm chart. Set the <code>config.burrito.hermitcrab</code> parameter to true in your values file to activate Hermitcrab.</p> <p>As the Provider Network Mirror Protocol only supports HTTPS traffic, it is required to provide Burrito runners &amp; the Hermitcrab server with some TLS configuration. By default, the Helm chart expects a secret named <code>burrito-hermitcrab-tls</code> to contain TLS configuration: <code>ca.crt</code>, <code>tls.crt</code>, and <code>tls.key</code>.</p>"},{"location":"operator-manual/provider-caching/#option-1-use-cert-manager","title":"Option 1: Use Cert-Manager","text":"<p>The Helm chart is packaged with Cert-Manager configuration to use for Burrito/Hermitcrab TLS encryption. Assuming that Cert-Manager is installed on your cluster, set the <code>hermitcrab.tls.certmanager.use</code> parameter to <code>true</code>. This setting adds a Cert-Manager Certificate resource to be used with Burrito. Provide Certificate spec with the <code>hermitcrab.tls.certmanager.spec</code> value. You must set the <code>secretName</code> value to the same value specified in <code>config.burrito.hermitcrab.certificateSecretName</code> (default <code>burrito-hermitcrab-tls</code>)</p>"},{"location":"operator-manual/provider-caching/#example-configuration-with-a-self-signed-issuer","title":"Example configuration with a self-signed issuer","text":"<p>Deploy Cert-Manager resources to generate self-signed certificates:</p> <pre><code>apiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: selfsigned-issuer\nspec:\n  selfSigned: {}\n---\napiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\n  name: my-selfsigned-ca\n  namespace: cert-manager\nspec:\n  isCA: true\n  commonName: my-selfsigned-ca\n  secretName: root-secret\n  privateKey:\n    algorithm: ECDSA\n    size: 256\n  issuerRef:\n    name: selfsigned-issuer\n    kind: ClusterIssuer\n    group: cert-manager.io\n---\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: my-ca-issuer\nspec:\n  ca:\n    secretName: root-secret\n</code></pre> <p>Update the Helm chart values to create a self-signed certificate:</p> <pre><code>config:\n  burrito:\n    hermitcrab:\n      enabled: true\n...\nhermitcrab:\n  tls:\n    certManager:\n      use: true\n      certificate:\n        spec:\n          secretName: burrito-hermitcrab-tls\n          commonName: burrito-hermitcrab.burrito.svc.cluster.local\n          dnsNames:\n            - burrito-hermitcrab.burrito.svc.cluster.local\n          issuerRef:\n            name: my-ca-issuer\n            kind: ClusterIssuer\n</code></pre> <p>Burrito runners should now use Hermitcrab as a network mirror for caching providers.</p>"},{"location":"operator-manual/provider-caching/#option-2-mount-a-custom-certificate","title":"Option 2: Mount a custom certificate","text":"<p>If Hermitcrab is activated using the Helm chart, Burrito expects a secret named <code>burrito-hermitcrab-tls</code> to contain TLS configuration: <code>ca.crt</code>, <code>tls.crt</code>, and <code>tls.key</code>. Assuming that Cert-Manager is installed on your cluster, set the <code>tls.certManager.use</code> value to true and specify an Issuer or ClusterIssuer with <code>tls.certManager.certificate.issuer.kind</code> and <code>tls.certManager.certificate.issuer.name</code> values. This will create a Certificate custom resource that will be used to ensure TLS between runners and Hermitcrab.</p>"},{"location":"operator-manual/provider-caching/#server-side","title":"Server side","text":"<p>Mount your custom certificate to <code>/etc/hermitcrab/tls/tls.crt</code> and the private key to <code>/etc/hermitcrab/tls/tls.key</code> by using the <code>hermitcrab.deployment.extraVolumeMounts</code> and <code>hermitcrab.deployment.extraVolumeMounts</code> values. Check out the Hermitcrab documentation for more information about injecting TLS Configuration.</p>"},{"location":"operator-manual/provider-caching/#runner-side","title":"Runner side","text":"<p>If Hermitcrab is activated using the Helm chart, the Burrito controller expects a secret named <code>burrito-hermitcrab-tls</code> to contain client TLS configuration in the <code>ca.crt</code> key. This private certificate will be trusted by Burrito runners.</p>"},{"location":"reference/","title":"Reference index","text":""},{"location":"user-guide/","title":"Overview","text":"<p>This guide is for developers who have burrito installed for them and are managing layers.</p> <p>Note</p> <p>Please make sure you've completed the getting started guide.</p>"},{"location":"user-guide/additionnal-trigger-path/","title":"Additionnal Trigger Paths","text":"<p>By default, when you are creating a layer, you must specify a repository and a path. This path is used to trigger the layer changes which means that when a change occurs in this path, the layer will be plan / apply accordingly.</p> <p>Sometimes, you need to trigger changes on a layer where the changes are not in the same path (e.g. update made on an internal terraform module hosted on the same repository).</p> <p>That's where the additional trigger paths feature comes!</p> <p>Let's take the following <code>TerraformLayer</code>:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets-terragrunt\nspec:\n  terraform:\n    enabled: true\n    version: \"1.3.1\"\n  terragrunt:\n    enabled: true\n    version: \"0.45.4\"\n  remediationStrategy:\n    autoApply: true\n  path: \"terragrunt/random-pets/test\"\n  branch: \"main\"\n  repository:\n    name: burrito\n    namespace: burrito\n</code></pre> <p>The repository's path of my <code>TerraformLayer</code> is set to <code>terragrunt/random-pets/test</code>. But I want to trigger the layer plan / apply when a change occurs on my module which is in the <code>modules/random-pets</code> directory of my repository.</p> <p>To do so, I just have to add the <code>config.terraform.padok.cloud/additionnal-trigger-paths</code> annotation to my <code>TerraformLayer</code> as follow:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets-terragrunt\n  annotations:\n    config.terraform.padok.cloud/additionnal-trigger-paths: \"modules/random-pets\"\nspec:\n  terraform:\n    enabled: true\n    version: \"1.3.1\"\n  terragrunt:\n    enabled: true\n    version: \"0.45.4\"\n  remediationStrategy:\n    autoApply: true\n  path: \"terragrunt/random-pets/test\"\n  branch: \"main\"\n  repository:\n    name: burrito\n    namespace: burrito\n</code></pre> <p>Now, when a change occurs in the <code>modules/random-pets</code> directory, the layer will be plan / apply.</p>"},{"location":"user-guide/override-runner/","title":"Override the runner pod spec","text":"<p>Both <code>TerraformRepository</code> and <code>TerraformLayer</code> expose a <code>spec.overrideRunnerSpec</code> map field.</p> <p>If the field is specified for a given <code>TerraformRepository</code> it will be applied by default to all <code>TerraformLayer</code> linked to it.</p> <p>If the field is specified for a given <code>TerraformLayer</code> it will take precedence over the <code>TerraformRepository</code> configuration.</p> <p>Available overrides are:</p> Fields <code>ImagePullSecrets</code> <code>Image</code> <code>Tolerations</code> <code>NodeSelector</code> <code>ServiceAccountName</code> <code>Resources</code> <code>Env</code> <code>EnvFrom</code> <code>Volumes</code> <code>VolumeMounts</code> <code>Metadata.Annotations</code> <code>Metadata.Labels</code> <p>For instance with the following configuration, all the runner pods will have the specifications described inside the <code>TerraformRepository</code>:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: burrito\n  namespace: burrito\nspec:\n  repository:\n    url: https://github.com/padok-team/burrito\n  terraform:\n    enabled: true\n  overrideRunnerSpec:\n    imagePullSecrets:\n    - name: ghcr-creds\n    tolerations:\n    - effect: NoSchedule\n      key: burrito.io/production\n      operator: Exists\n    nodeSelector:\n      production: \"true\"\n    serviceAccountName: \"production\"\n---\napiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets\n  namespace: burrito\nspec:\n  terraform:\n    version: \"1.3.1\"\n  path: \"internal/e2e/testdata/random-pets\"\n  branch: \"main\"\n  repository:\n    name: burrito\n    namespace: burrito\n</code></pre> <p>In the following case, <code>tolerations</code> and <code>nodeSelector</code> will be merged:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: burrito\n  namespace: burrito\nspec:\n  repository:\n    url: https://github.com/padok-team/burrito\n  terraform:\n    enabled: true\n  overrideRunnerSpec:\n    imagePullSecrets:\n    - name: ghcr-creds\n    tolerations:\n    - effect: NoExecute\n      key: burrito.io/production\n      operator: Exists\n    nodeSelector:\n      production: \"true\"\n    serviceAccountName: \"production\"\n---\napiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets\n  namespace: burrito\nspec:\n  terraform:\n    version: \"1.3.1\"\n  path: \"internal/e2e/testdata/random-pets\"\n  branch: \"main\"\n  repository:\n    name: burrito\n    namespace: burrito\n  overrideRunnerSpec:\n    tolerations:\n    - effect: NoSchedule\n      key: burrito.io/production\n      operator: Exists\n    nodeSelector: {}\n</code></pre> <p>Resulting in the following <code>podSpec</code>:</p> <pre><code>tolerations:\n- effect: NoSchedule\n  key: burrito.io/production\n  operator: Exists\nnodeSelector:\n  production: \"true\"\n</code></pre>"},{"location":"user-guide/private-modules/","title":"Configure the TerraformLayer to use private modules' repositories","text":"<p>If your stack use Terraform modules that are hosted on private repositories, you can configure the <code>TerraformLayer</code> to be able to use those private modules by configuring the <code>overrideRunnerSpec</code> in your resource definition.</p>"},{"location":"user-guide/private-modules/#the-layer-uses-a-private-module-with-https","title":"The layer uses a private module with HTTPS","text":""},{"location":"user-guide/private-modules/#1-create-a-secret-containing-a-git-credentilas-file","title":"1. Create a secret containing a .git-credentilas file","text":"<p>Create a Kubernetes Secret which looks like the following:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: git-credentials\nstringData:\n  .git-credentials: |\n    https://&lt;username&gt;:&lt;password | access_token&gt;@github.com\n</code></pre> <p>Info</p> <p>You can replace <code>github.com</code> with <code>gitlab.com</code> or any GitHub or GitLab URL.</p>"},{"location":"user-guide/private-modules/#2-create-a-configmap-for-configuring-the-git-agent","title":"2. Create a ConfigMap for configuring the git agent","text":"<p>Create a Kubernetes ConfigMap which looks like the following:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: gitconfig\ndata:\n  .gitconfig: |\n    [credential]\n        helper = store\n</code></pre>"},{"location":"user-guide/private-modules/#3-mount-those-configurations-files-in-the-runners-configuration","title":"3. Mount those configurations' files in the runners' configuration","text":"<p>You need to mount this Secret and ConfigMap as file with some VolumeMounts:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: terragrunt-private-module\nspec:\n  terraform:\n    enabled: true\n    version: \"1.3.1\"\n  terragrunt:\n    enabled: true\n    version: \"0.45.4\"\n  remediationStrategy:\n    autoApply: true\n  path: \"terragrunt/random-pets-private-module/test\"\n  branch: main\n  repository:\n    name: burrito\n    namespace: burrito\n  overrideRunnerSpec:\n    env:\n    volumes:\n    - name: gitconfig\n      configMap:\n        name: gitconfig\n    - name: git-credentials\n      secret:\n        secretName: git-credentials\n    volumeMounts:\n    - name: gitconfig\n      mountPath: /home/burrito/.gitconfig\n      subPath: .gitconfig\n    - name: git-credentials\n      mountPath: /home/burrito/.git-credentials\n      subPath: .git-credentials\n</code></pre>"},{"location":"user-guide/private-modules/#the-layer-uses-a-private-module-with-ssh","title":"The layer uses a private module with SSH","text":""},{"location":"user-guide/private-modules/#1-create-a-secret-with-a-ssh-private-key-which-can-pull-the-modules-repositories","title":"1. Create a Secret with a SSH private key which can pull the modules' repositories","text":"<p>Create a Kubernetes Secret which looks like the following:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: git-private-key\u2013modules\n  namespace: burrito\ntype: Opaque\nstringSata:\n  key: |\n    -----BEGIN OPENSSH PRIVATE KEY-----\n    ...\n    -----END OPENSSH PRIVATE KEY-----\n</code></pre> <p>Info</p> <p>You can update the Kubernetes ConfigmMap <code>burrito-ssh-known-hosts</code> to add others known hosts.</p>"},{"location":"user-guide/private-modules/#2-mount-this-secret-in-your-runner-spec","title":"2. Mount this Secret in your runner spec","text":"<p>You need to mount this Secret as a volume and add a <code>GIT_SSH_COMMAND</code> environements variables:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: terragrunt-private-module-ssh\nspec:\n  terraform:\n    version: \"1.3.1\"\n    enabled: true\n  terragrunt:\n    enabled: true\n    version: \"0.45.4\"\n  remediationStrategy:\n    autoApply: true\n  path: \"terragrunt/random-pets-private-module-ssh/test\"\n  branch: main\n  repository:\n    name: burrito\n    namespace: burrito\n  overrideRunnerSpec:\n    env:\n    - name: GIT_SSH_COMMAND\n      value: ssh -i /home/burrito/.ssh/key\n    volumes:\n    - name: private-key\n      secret:\n        secretName: private-key-ssh-module\n    volumeMounts:\n    - name: private-key\n      mountPath: /home/burrito/.ssh/key\n      subPath: key\n      readOnly: true\n</code></pre> <p>As you can see, we added a new <code>overrideRunnerSpec</code> field to the <code>TerraformLayer</code> spec. This field allows you to override the default runner pod spec. In this case, we added a new volume and a new environment variable to the runner pod spec:</p> <ul> <li>The volume is a secret volume that contains the SSH key we created earlier</li> <li>The environment variable is used to tell git to use the SSH key we added to the runner pod</li> </ul>"},{"location":"user-guide/remediation-strategy/","title":"Choose a remediation strategy","text":"<p>The remediation strategy is the way to tell Burrito how it should handle the remediation of drifts on your Terraform layers.</p> <p>As for the runner spec override, you can specify a <code>spec.remediationStrategy</code> either on the <code>TerraformRepository</code> or the <code>TerraformLayer</code>.</p> <p>The configuration of the <code>TerraformLayer</code> will take precedence.</p>"},{"location":"user-guide/remediation-strategy/#specremediationstrategy-api-reference","title":"<code>spec.remediationStrategy</code> API reference","text":"Field Type Default Effect <code>autoApply</code> Boolean <code>false</code> If <code>true</code> when a <code>plan</code> shows drift, it will run an <code>apply</code>. <code>onError.maxRetries</code> Integer <code>5</code> or value defined in Burrito configuration How many times Burrito should retry a <code>plan</code>/<code>apply</code> when a runner fails. <p>Warning</p> <p>This operator is still experimental. Use <code>spec.remediationStrategy.autoApply: true</code> at your own risk.</p>"},{"location":"user-guide/remediation-strategy/#example","title":"Example","text":"<p>With this example configuration, Burrito will create <code>apply</code> runs for this layer, with a maximum of 3 retries.</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets-terragrunt\nspec:\n  remediationStrategy:\n    autoApply: true\n    onError:\n      maxRetries: 3\n  # ... snipped ...\n</code></pre>"},{"location":"user-guide/terraform-version/","title":"Configure a Terraform/Terragrunt/OpenTofu version","text":"<p>By leveraging <code>tenv</code>, Burrito auto-detects the Terraform, Terragrunt or OpenTofu version used in your repository, with version constraints set in your code (see <code>tenv</code>'s README).</p> <p>Additionally, you can to specify version constraints in the <code>TerraformRepository</code> or <code>TerraformLayer</code> resource as described below.</p>"},{"location":"user-guide/terraform-version/#choose-terraform-version","title":"Choose Terraform version","text":"<p>Both <code>TerraformRepository</code> and <code>TerraformLayer</code> expose a <code>spec.terraform.version</code> map field that support version constraints as described in the Terraform documentation.</p> <p>If the field is specified for a given <code>TerraformRepository</code> it will be applied by default to all <code>TerraformLayer</code> linked to it.</p> <p>If the field is specified for a given <code>TerraformLayer</code> it will take precedence over the <code>TerraformRepository</code> configuration.</p>"},{"location":"user-guide/terraform-version/#enable-terragrunt","title":"Enable Terragrunt","text":"<p>You can specify usage of Terragrunt with the <code>spec.terraform.terragrunt</code> map as follow:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets-terragrunt\nspec:\n  terraform:\n    version: \"~&gt; 1.3.0\"\n    enabled: true\n  terragrunt:\n    enabled: true\n    version: \"0.44.5\"\n  remediationStrategy:\n    autoApply: false\n  path: \"internal/e2e/testdata/terragrunt/random-pets/prod\"\n  branch: \"feat/handle-terragrunt\"\n  repository:\n    name: burrito\n    namespace: burrito\n</code></pre> <p>Info</p> <p>This configuration can be specified at the <code>TerraformRepository</code> level to be enabled by default in each of its layers.</p>"},{"location":"user-guide/terraform-version/#use-opentofu-instead-of-terraform","title":"Use OpenTofu instead of Terraform","text":"<p>(coming soon)</p>"}]}